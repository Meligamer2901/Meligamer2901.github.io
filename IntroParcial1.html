<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- Responsive Tag -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introducción a los sistemas de cómputo: Parcial #1</title>
    <!--Dependencia CSS de bootstrap-->
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/introStyles/styles.css">
</head>
<body>
<!--Navbar Component-->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="Intro1.html">Introducción a los sistemas de cómputo</a>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav ml-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Inicio</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="DesarrolloHumano.html">Desarrollo Humano</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="metodologia.html">Metodología de la Investigación</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="contabilidad.html">Contabilidad I</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="logica.html">Lógica de Sistemas</a>
                    </li>
                </ul>
            </div>
        </div><!--END CONTAINER-->
    </nav><!--END NAVBAR-->
         <!-- CARROUSEL -->
    <div id="carousel" class="carousel slide" data-bs-ride="carousel">
        <div class="carousel-indicators">
          <button type="button" data-bs-target="#carousel" data-bs-slide-to="0" class="active" aria-current="true" aria-label="Slide 1"></button>
          <button type="button" data-bs-target="#carousel" data-bs-slide-to="1" aria-label="Slide 2"></button>
          <button type="button" data-bs-target="#carousel" data-bs-slide-to="2" aria-label="Slide 3"></button>
        </div><!-- END INDICATORS -->
        <div class="carousel-inner">
          <!-- SLIDE #1-->
          <div class="carousel-item active">
            <img src="introImg1/intro1img.jpg" class="d-block w-100" alt="Introduccion">
            <div class="carousel-caption d-none d-md-block">
              <h5 class="text-white">Introducción a los sistemas de cómputo</h5>
            </div>
          </div>
          <!-- SLIDE #2-->
          <div class="carousel-item">
            <img src="introImg1/intro4img.webp" class="d-block w-100" alt="Introduccion">
            <div class="carousel-caption d-none d-md-block">
              <h5 class="text-dark">Introducción a los sistemas de cómputo</h5>
            </div>
          </div>
          <!-- SLIDE #3-->
          <div class="carousel-item">
            <img src="introImg1/intro3img.jpg" class="d-block w-100" alt="Introduccion">
            <div class="carousel-caption d-none d-md-block">
              <h5>Introducción a los sistemas de cómputo</h5>
            </div>
          </div>
        </div><!-- END CARROUSEL INNER -->
        <!-- CONTROLADORES PREV & NEXT -->
        <button class="carousel-control-prev" type="button" data-bs-target="#carousel" data-bs-slide="prev">
          <span class="carousel-control-prev-icon" aria-hidden="true"></span>
          <span class="visually-hidden">Previous</span>
        </button>
        <button class="carousel-control-next" type="button" data-bs-target="#carousel" data-bs-slide="next">
          <span class="carousel-control-next-icon" aria-hidden="true"></span>
          <span class="visually-hidden">Next</span>
        </button>
      </div><!-- END CARROUSEL -->

      <!--CONTENT-->
      <p class="top-space"></p>
      <div class="container">
        <!--SECCIÓN 1-->
        <section class="row">
          <div class="col-12">
            <h1 class="display-1">Parcial #1</h1>
            <p class="justificar">
                Durante los meses comprendido de enero a marzo del año 2023, se estudiaron los primeros temas contenidos en los seis módulos que contiene
                el primer parcial. Esta primera porción del semestre está dividida en varias semanas, en las que se impartieron temas como: Arquitectura de las
                computadoras, CMD, Linux, Control de procesos, Sistema de computador y PCI etc. 
            </p>
            <p class="justificar">
              Durante la duración del curso se realizan pruebas parciales, tres para ser exactos. Estos parciales se realizan cada dos meses y están 
              fundamentados en módulos, que son impartidos en dos o tres semanas cada uno. Es por ello que el portafolio correspondiente al curso está
              dividido por parciales.
            </p>
          </div>
        </section>
        <p class="top-space"></p>

        <!-- SECCIÓN 2-->
        <section class="row">
            <div class="col-12">
                <h2 class="centrar">Módulo 1</h2>
                <br>
                <h3>Semana 1</h3>
                <br>
                <h4>Historia de la computadoras</h4>
                <h5>Informatica</h5>
                <p class="justificar">(Según la Real Academia Española de la Lengua) Es el conjunto de 
                    conocimientos científicos y técnicos para hacer posible el tratamiento automático de 
                    la información por medio de computadoras electrónicas.
                </p>
                <h5>computadora u Ordenador</h5>
                <p class="justificar">Es una máquina electrónica capaz de aceptar unos datos de entrada, efectuar 
                    con ellos una operaciones aritméticas y lógicas, y proporcionar la información resultante a través 
                    de un medio de salida.
                </p>
                <h5>Calculadora</h5>
                <p class="justificar">
                    (acepción actual) Es una máquina capaz de efectuar operaciones aritméticas bajo el control directo del usuario.  
                </p>
                <h5>Datos</h5>
                <p class="justificar">
                    Son conjuntos de símbolos utilizados para expresar o representar un valor numérico, un hecho, un objeto o una idea, 
                    codificada en la forma adecuada para ser objeto de tratamiento por medio de una computadora.  
                </p>
                <h5>Información</h5>
                <p class="justificar">
                    Datos tratados y organizados, con significado desde el punto de vista del usuario. 
                </p>
                </div>    
            <div class="col-12">
                <br>
                <br>
                <h4>Evolución de los sistemas de cálculo</h4>
                <h5>Ábaco</h5>
                <p class="justificar">
                    Serie de alambres paralelos, sujetos por los extremos en un armazón rectangular, sobre 
                    los que se pueden desplazar una serie de bolas o fichas.  
                </p>
                <br>
            </div>
            <h4>Calculadora Mecánica I</h4>
            <br>
            <br>
            <br>
            <div class="col-3">
                <h5>La calculadora de Sckickard</h5>
                <ul>
                    <li>En 1623 Wilhelm Sckickard construye la primera máquina de calcular.</li>
                </ul>
                </div>
                <div class="col-3">
                <h5>La Pascalina</h5>
                <ul>
                    <li>1.642 Blaise Pascal. Conjunto de discos dentados, cada uno de los 
                        cuales tiene 10 divisiones, que representaban un dígito. Es capaz de realizar sumas y restas.</li>
                </ul>
                </div>
                <div class="col-3">
                <h5>La Calculadora Universal</h5>
                <ul>
                    <li>1694 Gottfried W. Leibniz. Perfecciona la máquina de Pascal añadiéndole la multiplicación y división.</li>
                </ul>
                </div>
                <div class="col-3">
                <h5>La Lógica Matemática</h5>
                <ul>
                <li>George Boole (1815-1864), es el fundador de la teoría de la lógica matemática.</li>
                </ul>
                </div>
                <div class="col-2">
                 <img src="introImg1/CalUniimh.png" width="300px" alt="Introduccion" class="rounded">
                <br>
                <br>
                <br>
                </div>
            <h4>Calculadora Mecánica II</h4>
            <br>
            <br>
            <br>
                <h5>El padre de la computadora</h5>
                <p class="justificar">Se considera a Charles Babbage (1791- 1871), como el padre de los sistemas actuales 
                    de computación. A Charles Babbage se le atribuye el desarrollo de dos máquinas de cálculo:</p>
                <div class="col-3">
                <br>
                <br>
                <h5>La Máquina diferencial</h5>
                <p class="justificar">1694 Gottfried W. Leibniz. Perfecciona la máquina de Pascal añadiéndole la multiplicación y división.(1821) 
                    capaz de calcular polinomios de sexto grado y tabular mecánicamente hasta veinte cifras y ocho decimales</p>
                </div>
                <div class="col-3">
                <br>
                <br>
                <h5>La Maquina Analítica</h5>
                <p class="justificar">(1833) sistema mecánico precursor de la computadora del siglo XX. Disponía de:</p>
                <ul>
                <li>Dispositivo de entrada/salida de datos (tarjetas perforadas)</li>
                <li>Unidad de memoria</li>
                <li>Dispositivo de cálculo llamado "Mill" (Unidad Aritmética)</li>
                <li>Mecanismo de barras y palancas que accionaba el conjunto (Unidad de Control), conducido por un programa codificado sobre tarjetas perforadas.</li>
                </ul>
                <br>
                <br>
                </div>
                <div class="col-2">
                    <br>
                    <br>
                    <img src="introImg1/maquiAnaimg.avif" width="300px" alt="Introduccion" class="rounded">
                </div>
                <h5>La Máquina de Tabular</h5>
                <p class="justificar">En 1890 Herman Hollerith (1860-1929), inventó su máquina tabuladora que utilizaba corriente eléctrica para detectar los agujeros que 
                    estaban perforados y así hizo registrar la información en tarjetas, y el tiempo total del proceso se redujo. Sistema de automatización del censo.</p>
                    <div class="col-2">
                        <img src="introImg1/tabuladorimg.webp" width="300px" alt="Introduccion" class="rounded">
                    </div>
                    <p class="top-space"></p>
            <div class="col-10">
                <h4>La Primera Computadora I</h4>
                <br>
                <h5>La computadora electromecánica</h5>
                <p class="justificar">
                    Z-1 (1935) Konrad Zuse en Berlín desarrolló su computadora Z-1 Mark I Computer (ASCC) Automatic Sequence Controller Calculator (1944) Desde 1937 hasta 1944, 
                    IBM patrocinó el proyecto del Dr. Howard H. Aiken, profesor de la universidad de Harvard. En 1944 finalizó su objetivo con el nombre de Mark I
                </p>
                <br>
                <br>
            </div>
            <h4>La Primera Computadora II</h4>
            <br>
            <br>
            <br>
                <div class="col-3">
                <br>
                <h5>ABC</h5>
                <p class="justificar">(Atanasoff Berry Computer) (1936/37) John Vicent Atanasoff y Clifford Berry. Principios de las primeras computadoras.</p>
                </div>
                <div class="col-3">
                <br>
                <h5>ENIAC</h5>
                <p class="justificar">(Electronic Numerical Integrator and Computer) (1946) Construido en la universidad de Pennsylvania, por John W. Mauchly y John Presper Eckert</p>
                </div>
                <div class="col-2">
                    <img src="introImg1/ENIACimg.avif" width="300px" alt="Introduccion" class="rounded">
                </div>  
                <h4>Las primeras Computadoras III</h4>
            <br>
            <br>
            <br>
                <h5>Calculadoras de Von Neuman</h5>
                <p class="justificar">John Von Neumann (1903-1957) 1.946 "First Draft of a Report on to Edvac“ Principios ordenadores del tipo Von Neumann:</p>
                <ul>
                <li>Concepto de numeración codificada</li>
                <li>Almacenamiento del programa en memoria</li>
                <li>Perfeccionamiento de la ruptura de secuencia</li>
                </ul>
                <div class="col-3">
                    <br>
                    <br>
                    <h5>EDSAC</h5>
                    <p class="justificar">M. Wikes, de la Universidad de Cambridge</p>
                    </div>
                    <div class="col-3">
                    <br>
                    <br>
                    <h5>UNIVAC</h5>
                    <p class="justificar">Eckert y Mauchly, primera computadora adquirida con fines lucrativos.</p>
                    <br>
                    <br>
                    </div> 
            <h4>BABBAGE VS. VON NEUMAN</h4>
            <br>
            <br>
            <div class="col-2">
                <img src="introImg1/BabbVSVonimg.png" width="500px" alt="Introduccion" class="rounded">
           <br>
           <br>
           <br>
           <br>
        </div>
        <h4>Generaciones</h4>
        <br>
        <br>
        <div class="col-10"> 
            <h5>1ra. Generación (1940-52)</h5>
            <ul>
             <li>Tecnología empleada: Válvulas de Vacío.</li>
             <li>Uso: Científico y militar. </li>
             <li>Programación: Modificando directamente los valores de los circuitos de la máquina. No existían los lenguajes de programación, ni siquiera el ensamblador.</li>
             <li>Ordenadores caros, debido a la corta vida de la válvula de vacío y al gran calentamiento, así como al gran consumo de energía eléctrica.</li>
             <li>Ordenadores lentos.</li>
             <li>Capacidad de ejecutar más de una tarea a la vez.</li> 
            </ul>
        </div>
        <div class="col-10"> 
            <br>
            <br>
            <h5>2da. Generación (1952-64)</h5>
             <ul>
              <li>Disponía ya de una programación previa, de un sistema Operativo, capaz de interpretar instrucciones escritas en lenguajes de programación como COBOL o Fortran.</li>
              <li>Comienzo el desarrollo de periférico de E/S impresoras y los Lenguajes de alto nivel (y el ensamblador).</li>
              <li>El modo de trabajo era generalmente el sistema por lotes.</li>
              <li>Aumento de la velocidad en el cálculo.</li>
              <li>Reucción de tamaño.</li>
              <li>Reducción del consumo a energía y potencia disipada</li>
              <li>Tiempo de vida media del transistor superior a la válvula</li>
              <li>Abaratamiento</li>
             </ul>
        </div>
        <div class="col-10"> 
            <br>
            <br>
            <h5>3da. Generación (1952-64)</h5>
             <ul>
              <li>Tecnología empleada: Circuito integrado (lámina de silicio embutida en plástico). Se utiliza materiales semiconductores en lugar de los núcleos de ferrita en la construcción de memorias. </li>
              <li>Se mejoran los lenguajes de programación y empezaron a aparecer programas comerciales, con lo que un usuario no tenia que programas sus aplicaciones.</li>
              <li>Capacidad de multiprogramación, con lo cual los ordenadores son capaces de ejecutar varias tareas al mismo tiempo.</li>
              <li>Aumento en la velocidad de cálculo.</li>
              <li>Tamaño disminuye.</li>
            </ul>
        </div>
        <div class="col-10"> 
            <br>
            <br>
            <h5>4da. Generación (1952-64)</h5>
             <ul>
              <li>Tecnología empleada: Circuitos delata escala de integración. Microprocesadores. Es el producto de una serie de avances tanto en el hardware, y su tecnología de fabricación, 
                como en el software y sus posibilidades de aplicación.</li>
              <li>Nuevas tecnologías de fabricación de semiconductores que conducen a velocidades de transmisión cada vez mayores y mayor capacidad de almacenamiento.</li>
              <li>Aparición de paquetes software, que obedecen a nuevas concepciones y situaciones específicas: bases de datos, diseño asistido, tratamiento de texto.</li>
              <li>Nuevas memorias de al almacenamiento: tecnologías Winchester, y burbujas magnéticas.</li>
              <li>Aparición de los ordenadores personales.</li>
              <li>Mas lenguajes de alto nivel y herramientas as informáticas.</li>
              <li>Desarrollo de periféricos inteligentes: descargan de trabajo a la CPU.</li>
              <li>Hacia mediados de los 80, comienza el desarrollo de redes de computadoras personales que corren sistemas operativos en red y sistemas operativos distribuidos.</li>
            </ul>
        </div>
        <div class="col-10"> 
            <br>
            <br>
            <h5>5da. Generación (1952-64)</h5>
             <ul>
              <li>Arquitectura es diferente a la propuesta por Von Neuman.</li>
              <li>Ordenadores inferentes.</li>
              <li>Ordenadores de trasputers.</li>
              <li>Ordenador óptico.</li>
              <li>Máquinas neuronales.</li>
              <li>Sistemas informáticos distribuidos.</li>
            </ul>
            <br>
            <br>
        </div>
        <h4>Generaciones de Ordenador Personal</h4>
        <br>
        <div class="col-10"> 
         <ul>
          <li>Años 70, primer microprocesador, el INTEL 4004, posibilidad de construcción de un ordenador utilizado por un solo usuario.</li>
          <li>1997, S. Wozniak y S. Jobs, fueron una empresa llamada Apple.</li>
          <li>1981, IBM PC (Personal Computer).</li>
          <li>Evolución tanto en el microprocesador Utilizado (8088, 8086, 80286, 80486, Pentium) y el sistema operativo (UNIX para PC, 
            el OS/2 de IBM y el Windows-NT, Win95, Win98 de Microsoft).</li>
          <li>Mediados de los 80, comienza el desarrollo de redes de computadora personales.</li>
        </ul>
        <br>
        <br>
        </div>
        <h4>Sexta Generación</h4>
         <p class="justificar">(1990- ?) Se caracteriza por la evolución de las comunicaciones a la par de la tecnología. 
            La miniaturización de componentes en las máquinas, y su reducción en costo conllevan a sistemas de alta capacidad. 
            Cuentan con arquitecturas combinadas Paralelo / Vectorial, con cientos de microprocesadores vectoriales trabajando al 
            mismo tiempo; se han creado computadoras capaces de realizar más de un millón de millones de operaciones aritméticas 
            de punto flotante por segundo (teraflops).El uso de redes se hace común, con grandes velocidades y la integración de 
            servicios de video de calidad, voz y otros datos multimedia en tiempo real.
         </p>
        <br>
        <br>
        <h4>Clasificación de computadoras</h4>
        <div class="col-10">
            <img src="introImg1/Clasfimg.png" width="500px" alt="Introduccion" class="rounded">
        <br>
        <br>
        <br>
        <br>
        </div>
        <div class="col-3">
            <h5>Computadoras analógicas</h5>
            <ul>
                <li>Perciben: valores, señales y magnitudes físicas.</li>
                <li>Más rápidas</li>
                <li>La programación no es necesaria.</li>
                <li>Supervisa el mundo real: Viento, Temperatura, Sonido y Movimiento.</li>
                <li>Son máquina de propósitos específicos </li>
            </ul>
            </div>
            <div class="col-3">
            <h5>Computadoras digitales</h5>
            <ul>
                <li>Operan contando números.</li>
                <li>Máquinas de propósito general.</li>
                <li>Gran memoria interna.</li>
                <li>Gran utilidad a nivel: Comercial, científico y educativo.</li>
            </ul>
            </div>
            <div class="col-3">
            <h5>Computadoras hibridas</h5>
            <ul>
                <li>Son una combinación de las analógicas y las digitales, mas sus características.</li>
            </ul>
            </div>
            <div class="col-3">
                <h5>Supercomputadoras</h5>
                <ul>
                    <li>Altos niveles de costo con comercialización mínima: Búsqueda y estudio de la energía y armas nucleares, estudio del clima y elaboración de maquetas.</li>
                </ul>
                </div>
                <div class="col-3">
                <h5>Macrocomputadoras o Mainframes</h5>
                <ul>
                    <li>Grande, Potente y Costosa.</li>
                    <li>Procesamiento de datos.</li>
                    <li>Campos de Utilidad.</li>
                    <li>Marca IBM Dominio mercado.</li>
                    <li>Cientos de usuarios simultáneamente.</li>
                    <li>Años de funcionamiento sin interrupciones.</li>
                    <li>Espacio, piso falso temperatura controlada.</li>
                </ul>
                </div>
                <div class="col-2">
                    <img src="introImg1/superimg.png" width=500px" alt="Introduccion" class="rounded">
                <br>
                <br>
                <br>
                <br>
                </div>
            <h4>Diferencias</h4>
            <br>
            <br>
            <div class="col-3">
                <h5>Macrocomputadoras</h5>
                 <ul>
                  <li>Son mas poderosas, soportan más programas simultáneos.</li>
                  <li>Problemas limitados-fiabilidad.</li>
                  <li>Tienen de uno o varios docentes de procesadores.</li>
                  <li>Su aplicación: administración publica.</li>
                  <li>Calculo simples con bases de datos. </li>
                </ul>
            </div>
            <div class="col-3">
            <h5>Supercomputadoras</h5>
            <ul>
                <li>Pueden ejecutar un solo programa más rápido.</li>
                <li>Problemas limitados–velocidad.</li>
                <li>Trabajan con paralelismo masivo.</li>
                <li>Su aplicación: la ciencia y el ejército.</li>
                <li>Cálculos complicados con la memoria.</li>
            </ul>
            </div>
            <div class="col-3">
            <h5>Minicomputador</h5>
            <ul>
                <li>Es de nivel medio.</li>
                <li>Realiza cálculos complejos.</li>
                <li>Gestiona gran cantidad de usuarios de conectados.</li>
                <li>Es una versión mas pequeña que la macrocomputadora.</li>
                <li>Utilidad</li>
            </ul>
            </div>
            <div class="col-3">
                <h5>Microcomputador </h5>
                <ul>
                    <li>Dispositivos electrónicos.</li>
                    <li>Microprocesador CPU.</li>
                    <li>Sobremesa o portátil.</li>
                    <li>Herramienta de trabajo y entrenamiento.</li>
                    <li>Circuito integrado.</li>
                    <li>Velocidad.</li>
                    <li>Almacenamiento.</li>
                    <li>Miniaturización.</li>
                </ul>
                <br>
                <br>
                </div>
            <h4>Según su aplicación</h4>
            <div class="col-3">
            <ul>
                <li>Computadoras de aplicación general.</li>
                <li>Computadoras de aplicación especifica o especial.</li>
            </ul>
            <br>
            <br>
            </div>
            <h4>Siguiente generación de Computadoras</h4>
            <p class="justificar">Otras Alternativas: Computación molecular, computación óptica y computación cuántica.</p>
            <br>
            <br>
            <br>
            <br>
            <!--SECCIÓN 2-->
            <h2 class="centrar">Módulo 2</h2>
            <p class="top-space"></p>
            <h3>Semana 2</h3>
            <br>
            <div class="col-9">
                <br>
                <h4>Software</h4>
                    <h5>Clasificaciones de software</h5>
                    <ul>
                        <li><strong>Sistemas Operativos:</strong> El sistema operativo es el gestor y organizador de todas las actividades que realiza la computadora. Marca las pautas según las cuales se intercambia información entre la memoria central y la externa, y determina las operaciones elementales que puede realizar el procesador.</li>
                        <li><strong>Lenguajes de Programación:</strong> Mediante los programas se indica a la computadora que tarea debe realizar y cómo efectuarla , pero para ello es preciso introducir estas órdenes en un lenguaje que el sistema pueda entender. En principio, el ordenador sólo entiende las instrucciones en código máquina, es decir ,el específico de la computadora. Sin embargo, a partir de éstos se elaboran los llamados lenguajes de alto y bajo nivel.</li>
                        <li><strong>Software de aplicaciones:</strong> El software de aplicación está diseñado y escrito para realizar tareas específicas personales, empresariales o científicas como el procesamiento de nóminas, la administración de los recursos humanos o el control de inventarios. Todas estas aplicaciones procesan datos (recepción de materiales) y generan información (registros de nómina). para el usuario.</li>
                    </ul>
                    <br>
                <h4>Hardware</h4>
                <p class="justificar">Los componentes y dispositivos del Hardware se dividen en: Hardware Básico y Hardware Complementario.</p>
                    <div>
                    <ul>
                        <li>El Hardware Básico: son las piezas fundamentales e imprescindibles
                            para que la computadora funcione como son: Placa base, monitor,
                            teclado y ratón.
                            </li>
                        <li>El Hardware Complementario: son todos aquellos dispositivos
                            adicionales no esenciales como pueden ser: impresora, escáner,
                            cámara de vídeo digital, webcam, etc.
                            </li>
                    </ul>
                    </div>
                    <h5>Grupo de Hardware</h5>
                    <p class="justificar">Según sus funciones, los componentes y dispositivos del hardware se dividen en varios grupos y en el siguiente orden:</p>
                    <div>
                        <ul>
                            <li>Dispositivos de Entrada</li>
                            <li>Chipset (Circuito Integrado Auxiliar)</li>
                            <li>Unidad Central de Procesamiento (CPU)</li>
                            <li>Unidad de Control</li>
                            <li>Unidad Aritmético-Lógica</li>
                            <li>Unidad de Almacenamiento</li>
                            <li>Memoria Principal o Primaria (RAM – ROM)</li>
                            <li>Memoria Secundaria o Auxiliar (Disco Duro, Flexible, etc.)</li>
                            <li>Dispositivos de Salida</li>
                        </ul>
                        <br>
                        <br>
                    </div>
                    <h4>Firmware</h4>
                    <p class="justificar">El firmware es un bloque de instrucciones de programa para propósitos específicos, grabado en una memoria de tipo no volátil (ROM, EEPROM, flash, etc), que establece la lógica de más bajo nivel que controla los circuitos electrónicos de un dispositivo de cualquier tipo. Al estar integrado en la electrónica del dispositivo es en parte hardware, pero también es software, ya que proporciona lógica y se dispone en algún tipo de lenguaje de programación. Funcionalmente, el firmware es el intermediario (interfaz) entre las órdenes externas que recibe el dispositivo y su electrónica.</p>
                    <br>
                    <br>
                    <h4>Middleware</h4>
                    <p class="justificar">Middleware es un software que asiste a una aplicación para interactuar o comunicarse con otras aplicaciones, software, redes, hardware y/o sistemas operativos. Éste simplifica el trabajo de los programadores en la compleja tarea de generar las conexiones que son necesarias en los sistemas distribuidos. De esta forma se provee una solución que mejora la calidad de servicio, seguridad, envío de mensajes, directorio de servicio.</p>
                    <br>
                    <br>
                    <h4>Conectividad</h4>
                    <p class="justificar">Conectividad es la capacidad de un dispositivo (ordenador personal, periférico, PDA, móvil, robot, electrodoméstico, automóvil, etc.) de poder ser conectado (generalmente a un ordenador personal u otro dispositivo electrónico) sin la necesidad de un ordenador, es decir en forma autónoma. Asimismo, es el grado de conexión entre entidades sociales, gubernamentales y de cualquier índole entre sí.</p>
                    <div>
                        <ul>
                            <li>Bluetooth</li>
                            <li>Red de computadoras</li>
                            <li>WI-FI</li>
                            <li>WIMAX</li>
                        </ul>
                    </div>
                    <h4>Bit</h4>
                    <p class="justificar">Bit es el acrónimo Binary digit. (dígito binario). Un bit es un dígito del sistema de numeración binario. Mientras que en el sistema de numeración decimal se usan diez dígitos, en el binario se usan sólo dos dígitos, el 0 y el 1. Un bit o dígito binario puede representar uno de esos dos valores, 0 ó 1.</p>
                    <div>
                        <ul>
                            <li>Se puede imaginar un bit, como una bombilla que puede estar en uno de los siguientes dos estados:</li>
                        </ul>
                    </div>
                    <div class="col-2">
                    <img src="introImg1/Bit1img.png" width=500px" alt="Introduccion" class="rounded">
                    <br>
                    <br>
                    </div>
                    <p class="justificar">El bit es la unidad mínima de información empleada en informática, en cualquier dispositivo digital, o en la teoría de la información.</p>
                    </div>
                    <h4>Byte</h4>
                    <p class="justificar">Un byte se define como la unidad básica de almacenamiento de la información, habitualmente compuesto por 8 bits (unidad mínima de información que puede ser 1 -encendido- o 0 -apagado). A partir del byte surge el Kb (kilobyte), el Mb (megabyte), el Gb (gigabyte), etc. que representan distintas potencias de 2, puesto que se trabaja en sistema binario. Así el Kb son 2 elevado a 10 (1024), el Mb 2 elevado a 20 (1048576) y así sucesivamente.</p>
                    <p class="justificar">La notación del Sistema Internacional de Unidades utiliza el sistema decimal y trabaja sobre potencias de 10. Un Kb serían 10 elevado a 3 (1000), un Mb 10 elevado a 6 (1000000), etc.</p>
                    <br>
                    <br>
                    <h4>Cuantificación de bits y bytes</h4>
                    <div class="col-2">
                        <br>
                        <img src="introImg1/CuanBBYimg.png" width=500px" alt="Introduccion" class="rounded">
                        <br>
                        <br>
                        <br>
                        </div>
                    <div>
                        <table class="table table-dark table-striped">
                            <tr>
                                <th>Nombre</th>
                                <th>Abrev.</th>
                                <th>Factor binario</th>
                                <th>Tamaño en el SI</th>
                            </tr>
                            <tr>
                                <td>Bytes</td>
                                <td>B</td>
                                <td>2⁰=1</td>
                                <td>10⁰=1</td>
                            </tr>
                            <tr>
                                <td>Kilo</td>
                                <td>K</td>
                                <td>2¹⁰=1024</td>
                                <td>10³=1000</td>
                            </tr>
                            <tr>
                                <td>Mega</td>
                                <td>M</td>
                                <td>2²⁰=1,048,576</td>
                                <td>10⁶=1,000,000</td>
                            </tr>
                            <tr>
                                <td>Giga</td>
                                <td>G</td>
                                <td>2³⁰=1,073,741,824</td>
                                <td>10⁹=1,000,000,000</td>
                            </tr>
                            <tr>
                                <td>Tera</td>
                                <td>T</td>
                                <td>2⁴⁰= 1,099,511,627,776</td>
                                <td>10¹²=1,000,000,000,000</td>
                            </tr>
                            <tr>
                                <td>Peta</td>
                                <td>P</td>
                                <td>2⁴⁰= 1,125,899,906,842,624</td>
                                <td>10¹⁵=1,000,000,000,000,000</td>
                            </tr>
                            <tr>
                                <td>Exa</td>
                                <td>E</td>
                                <td>2⁶⁰= 1,152,921,504,606,846,976</td>
                                <td>10¹⁸=1,000,000,000,000,000,000</td>
                            </tr>
                            <tr>
                                <td>Zetta</td>
                                <td>Z</td>
                                <td>2⁷⁰= 1,180,591,620,717,411,303,424</td>
                                <td>10²¹=1,000,000,000,000,000,000,000</td>
                            </tr>
                            <tr>
                                <td>Yotta</td>
                                <td>Y</td>
                                <td>2⁸⁰= 1,208,925,819,614,629,174,706,176</td>
                                <td>10²⁴=1,000,000,000,000,000,000,000,000</td>
                            </tr>
                        </table>
                        <br>
                        <br>
                        <h4>Links</h4>
             <p class="justificar">Estos son algunos links interesantes que se vieron en el modulo</p>
             <table class="table table-dark table-striped">
                 <tr>
                     <th>Links</th>
                 </tr>
                 <tr>
                     <td><a href="https://edu.gcfglobal.org/es/conceptos-basicos-de-programacion/sistema-binario/1/" target="_blank">Bit</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://es.wikipedia.org/wiki/Byte" target="_blank">Byte</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://www.youtube.com/watch?v=49Y70pV8QFU&ab_channel=EasyTricks" target="_blank">Video: conversión de medidas de almacenamiento</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://www.youtube.com/watch?v=c-hyLLdDt7I&ab_channel=EliezerDeLe%C3%B3n" target="_blank">Video: Conversión de Binario a Decimal y de Decimal a Binario</a></td>
                 </tr>
             </table>
        </div>
                    <!--SECCIÓN 3-->
                    
                <h2 class="centrar">Módulo 3</h2>
                 <p class="top-space"></p>
                 <h3>Semana 3</h3>
                 <br>
                <div class="col-9">
                <br>
                <h4>Arquitectura de computadoras</h4>
                    <p class="justificar">
                        El concepto de arquitectura en el entorno informático 
                        proporciona una descripción de la construcción y distribución 
                        física de los componentes de la computadora. La arquitectura de 
                        una computadora explica la situación de sus componentes y 
                        permite determinar las posibilidades de que un sistema informático, 
                        con una determinada configuración, pueda realizar las operaciones 
                        para las que se va a utilizar.</p>
                 <br>
                <h4>Componentes básicos de una microcomputadoras</h4>
                 <ul>
                    <li>La tarjeta principal (Mother Board).</li>
                    <li>La CPU.</li>
                    <li>La memoria.</li>
                    <li>Los buses.</li>
                    <li>La fuente de alimentación.</li>
                 </ul>
                 <br>
                 <h4>Estructura de una computadora y sus periféricos</h4>
                 <div class="col-2">
                    <img src="introImg1/EstruIMG.png" alt="Introduccion" class="rounded">
                </div>
                <br>
                <br>
                <h4>¿Qué es la tarjeta pricipal?</h4>
                  <h5>Componentes de la trajeta principal</h5>
                   <ul>
                     <li>Zócalo del microprocesador.</li>
                     <li>Ranuras de memoria (SIMM, DIMM...).</li>
                     <li>Chipset de control.</li>
                     <li>BIOS.</li>
                     <li>Slots de expansión (ISA, PCI, AGP...).</li>
                     <li>Memoria caché.</li>
                     <li>Conectores internos.</li>
                     <li>Conectores externos.</li>
                     <li>Conector eléctrico.</li>
                     <li>Pila.</li>
                     <li>Elementos integrados variados.</li>
                   </ul>
                   <br>
                   <br>
                   <h4>La Mother Board</h4>
                   <div class="col-2">
                      <img src="introImg1/Motherimg.png" alt="Introduccion" class="rounded">
                  </div> 
                  <br>
                  <br>
                  <h4>CPU</h4>
                  <p>El CPU o Unidad de Procesamiento Central, es la parte central de toda 
                    computadora ya que es la que cumple la tarea de procesamiento de todas 
                    las funciones, así como también de almacenamiento de la información. 
                    Es un circuito electrónico que ha existido desde siempre en las computadoras 
                    sin importar su modelo y es por eso que es considerado uno de los elementos 
                    básicos de cualquier computador.</p>
                    <br>
                    <br>
                   <h4>Ciclos de reloj</h4>
                   <p>Casi todas las computadoras son construidas usando un reloj (Oscilador de cristal), 
                    que es utilizado para sincronizar los eventos u operaciones: determinando cuándo ocurren 
                    (el paso) en el hardware. Estos intervalos de tiempo, se denominan ciclos de reloj. Los ciclos de reloj (Ej: 400 picosegundos (ps)) se suelen transformar o usar como frecuencia de reloj (2.5 gigahertz (GHz)).</p>
                   <br>
                    <h4>Los buses</h4>
                   <p>Los buses son los canales de datos que interconectan los componentes de la PC. Algunos están diseñados para transferencias pequeñas, y otros para transferencias mayores.</p>
                   <div class="col-2">
                    <img src="introImg1/Bus1img.png" width="350px" alt="Introduccion" class="rounded">
                   </div>
                   <br>
                   <br>
                   <h5>Buses en una computadora</h5>
                   <p>Originalmente las primeras IBM PC, contaban con un bus único para interconectar todas las componentes del sistema, llamado BUS DEL SISTEMA. Con el tiempo éste empezó a ser incapaz de soportar los caudales de datos que requerían todos los componentes</p>
                   <div class="col-2">
                    <img src="introImg1/Bus2img.png" alt="Introduccion" class="rounded">
                   </div>
                   <br>
                   <p>El bus más importante de la PC se encarga del tráfico “pesado” entre la CPU y la memoria RAM 
                    conocido como:
                    </p>
                    <ul>
                        <li>Bus Frontal o Frontal Side Bus (FSB).</li>
                        <li>Bus del sistema ( en PC ́s más antiguas).</li>
                    </ul>
                    <div class="col-2">
                        <img src="introImg1/Bus3img.png" width="500px" alt="Introduccion" class="rounded">
                       </div>
                       <br>
                       <br>
                    <h5>Buses en un PC.</h5>
                    <br>
                    <h5>Tipos genéricos de buses</h5>
                    <ul>
                        <li>Bus del sistema, que es el encargado de unir la CPU con la memoria RAM y otros elementos de la tarjeta madre.</li>
                        <li>Bus de Entrada/Salida, que une la tarjeta madre con otros adaptadores y tarjetas ( de video, gráficas, discos duros etc.)</li>
                    </ul>
                    <br>
                    <br>
                    <h5>Bus PCI</h5>
                    <ul>
                        <li>Bus de expansión diseñado para los ix86 y Pentium.</li>
                        <li>Actualmente se encuentra en todos los computadores personales.</li>
                        <li>Soporta hasta 10 periféricos de alta velocidad.</li>
                        <li>Permite conexión con otros buses más</li>
                        <li>Bus de datos de 32 bits en la versión 2.0 y de 64 bits en la versión 2.1.</li>
                        <li>Bus de direcciones de 32 bits.</li>
                        <li>Funciona a 33 MHz (versión 2.0) o a 66 MHz (versión2.1).</li>
                        <li>La velocidad de transferencia máxima es.</li>
                    </ul>
                    <br>
                    <br>
                    <h5>¿Qué diferencia tiene el bus PCI 32 bits respecto al PCI de 64 Bits?</h5>
                    <p>La diferencia fundamental entre las diferentes versiones de buses PCI es principalmente la capacidad de datos que pueden procesar en una unidad de tiempo, es decir, el ancho de banda que son capaces de soportar. Este ancho de banda máximo o teórico se calcula multiplicando el número de bits utilizado por el bus para transferir datos en paralelo por la frecuencia de funcionamiento.</p>
                    <p>El bus PCI estándar utiliza datos de 32 bits y funciona a una frecuencia de 33 MHz. El máximo ancho de banda que admiten estos buses es de: 32 bits = 4 bytes por ciclo de reloj; 4 * 33.333 = 133.332 KBps = 133 MBps. Algunas placas utilizan buses PCI de 32 bits y 66 MHz, aumentando así la capacidad máxima de transferencia de los PCI originales, hasta 266 MBps. También existen bus PCI de 64 bits y 33 MHz, y de 64 bits y 66 Mhz.</p>
                    <h5>Características de los buses</h5>
                    <br>
                    <table class="table table-dark table-striped">
                        <tr>
                            <th>Nombre</th>
                            <th>Año</th>
                            <th>Anchura de datos</th>
                            <th>Velocidad de trasferencia</th>
                        </tr>
                        <tr>
                            <td>ISA (Bus-PC,PC-XT)</td>
                            <td>1980-82</td>
                            <td>8 bits</td>
                            <td>4-6 MB/s</td>
                        </tr>
                        <tr>
                            <td>ISA-AT</td>
                            <td>1984</td>
                            <td>16 bits</td>
                            <td>8-16,7 MB/s</td>
                        </tr>
                        <tr>
                            <td>MICA</td>
                            <td>1987</td>
                            <td>32 bits</td>
                            <td>40 MB/s</td>
                        </tr>
                        <tr>
                            <td>EISA</td>
                            <td>1988</td>
                            <td>32 bits</td>
                            <td>40 MB/s</td>
                        </tr>
                        <tr>
                            <td>VL-Bus</td>
                            <td>1993</td>
                            <td>32, 64 bits</td>
                            <td>132 MB/s, 250 MB/s</td>
                        </tr>
                        <tr>
                            <td>PCI</td>
                            <td>1991</td>
                            <td>32/64 bits</td>
                            <td>133 MB/s / 264 MB/s</td>
                        </tr>
                        <tr>
                            <td>PCI 2.0</td>
                            <td>1993</td>
                            <td>32/64 bits</td>
                            <td>264 MB/s / 528 MB/s</td>
                        </tr>
                        <tr>
                            <td>PCI-X 2.0</td>
                            <td>2002</td>
                            <td>32, 64 bits</td>
                            <td>2,1 GB/s, 4,2 GB/s</td>
                        </tr>
                    </table>
                    <br>
                    <h4>Generacion de Microprocesadores</h4>
                    <br>
                    <table class="table table-dark table-striped">
                        <tr>
                            <th>Generación</th>
                            <th>CPU</th>
                            <th>Año</th>
                            <th>Transistores</th>
                        </tr>
                        <tr>
                            <td>1era.</td>
                            <td>8086, 8088</td>
                            <td>1978-1981</td>
                            <td>29,000</td>
                        </tr>
                        <tr>
                            <td>2da.</td>
                            <td>80286</td>
                            <td>1984</td>
                            <td>134,000</td>
                        </tr>
                        <tr>
                            <td>3ra.</td>
                            <td>80286Dx</td>
                            <td>1987-88</td>
                            <td>275,000</td>
                        </tr>
                        <tr>
                            <td>4ta.</td>
                            <td>80486SX, 486DX</td>
                            <td>1990-92</td>
                            <td>1,200,000</td>
                        </tr>
                        <tr>
                            <td>5ta.</td>
                            <td>Petium/AMD K5</td>
                            <td>1993-95</td>
                            <td>3,100,000</td>
                        </tr>
                        <tr>
                            <td>6ta.</td>
                            <td>Petium pro/AMD K6</td>
                            <td>1995-98</td>
                            <td>5,500,000</td>
                        </tr>
                        <tr>
                            <td>7ma.</td>
                            <td>AMD K7 / Petium 4</td>
                            <td>1999-2000</td>
                            <td>22,000,000</td>
                        </tr>
                        <tr>
                            <td>8va.</td>
                            <td>Athlon 64 / Prescott</td>
                            <td>2003</td>
                            <td>10,000,000</td>
                        </tr>
                    </table>
                    <br>
                    <br> 
                    <h4>Procesadores Intel</h4>
                    <div class="col-2">
                        <img src="introImg1/pronintelimg.png" width="700px" alt="Introduccion" class="rounded">
                    </div>
                    <br>
                    <br>
                    <h4>Procesadores AMD</h4>
                    <div class="col-2">
                        <img src="introImg1/ProAMDimg.png" width="700px" alt="Introduccion" class="rounded">
                    </div>
                    <br>
                    <br>
                    <h4>Procesadores XEON</h4>
                    <div class="col-2">
                        <img src="introImg1/ProXeonimg.png" width="700px" alt="Introduccion" class="rounded">
                    </div>
                    <br>
                    <br>
                    <h4>Sistemas Operativos</h4>
                    <p class="justificar">Sistema tipo software que controla la computadora y administra los servicios y sus funciones como así también la ejecución de otros programas compatibles con éste. </p>
                    <ul>
                        <li>Ejemplos de familias de sistemas operativos: Windows, Unix, Linux, DOS, Mac OS, etc. </li>
                    </ul>
                    <p class="justificar">Un sistema operativo permite interactuar con el hardware de computadoras, teléfonos celulares, PDAs, etc. y ejecutar programas compatibles en éstos. Permite controlar las asignaciones de memoria, ordenar las solicitudes al sistema, controlar los dispositivos de entrada y salida, facilitar la conexión a redes y el manejo de archivos.</p>
                    <br>
                    <br>
                    <br>
                    <h4>Links</h4>
             <p class="justificar">Estos son algunos links interesantes que se vieron en el modulo</p>
             <table class="table table-dark table-striped">
                 <tr>
                     <th>Links</th>
                 </tr>
                 <tr>
                     <td><a href="https://elcodigoascii.com.ar/" target="_blank">Código ASCII</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://www.profesionalreview.com/2021/07/18/risc-vs-cisc/#:~:text=Los%20procesadores%20de%20arquitectura%20CISC,Qualcomm%20Snapdragon%20y%20Samsung%20Exynos." target="_blank">Arquitectura de procesadores RISC y CISC</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://www.xataka.com/basics/que-significa-que-mi-cpu-sea-de-32-o-64-bits-y-cual-es-la-diferencia#:~:text=En%20el%20mundo%20de%20la,los%20%C3%BAnicos%20con%20los%20otros." target="_blank">Procesadores de 32 bit y 64 bit</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://www.xataka.com/basics/tipos-memoria-ram-como-elegir-cual-se-adapta-a-que-necesitas" target="_blank">Tipos de memoria RAM</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://10tipos.com/tipos-de-procesadores/" target="_blank">Tipos de procesadores</a></td>
                 </tr>
                 <tr>
                    <td><a href="https://mpsoftware.com.mx/diferencias-entre-mantenimiento-preventivo-y-correctivo/#:~:text=El%20mantenimiento%20preventivo%20se%20realiza,de%20funcionar%20o%20est%C3%A1n%20da%C3%B1ados." target="_blank">Mantenimiento preventivo y Correctivo de computadoras</a></td>
                </tr>
                <tr>
                    <td><a href="https://www.xataka.com/seleccion/como-limpiar-ordenador-dentro-fuera-instrucciones-seguridad-que-necesitas-procedimiento" target="_blank">Limpieza de un ordenador</a></td>
                </tr>
             </table>
             </div>
                
                <!--SECCIÓN 4-->
                <h2 class="centrar">Módulo 4</h2>
                <p class="top-space"></p>
                <h3>Semana 4</h3>
                <br>
               <div class="col-9">
               <br>
               <h4>Servicio del sistema operativo</h4>
               <br>
               <h5>Ejecución de Programas</h5>
               <p class="justificar">apacidad del sistema de cargar un programa en memoria y ejecutarlo</p>
               <br>
               <h5>Operaciones E/S</h5>
               <p class="justificar">Dado que los programas no pueden ejecutar operaciones de E/S directamente, el sistema operativo debe proveer medios para realizarlas.</p>
               <br>
               <h5>Manipulación del sistema del archivo</h5>
               <p class="justificar">Capacidad de los programas de leer, escribir, crear y borrar archivos.</p>
               <br>
               <h5>Comunicaciones</h5>
               <p class="justificar">Intercambio de información entre procesos ejecutando en la misma computadora o en otra conectada a través de una red. Implementada mediante memoria compartida o por paso de mensajes.</p>
               <br>
               <h5>Detección de errores</h5>
               <p class="justificar">Asegurar un cómputo correcto mediante la detección de error en el CPU, memoria, dispositivos de E/S o en los programas de usuario.</p>
               <br>
               </div>
               <h4>Estructura de un sistema operativo</h4>
               <br>
               <br>
               <div>
               <h4>Evolucion de los SSOO</h4>
               <br>
               <h5>Monitor simple residente</h5>
               <p class="justificar">Programa que actúa como interfaz entre el usuario de un ordenador y el hardware de este, ofreciendo el entorno necesario para que el usuario pueda ejecutar programas.</p>
               <ul>
                 <li><strong>Visión de Máquina virtual:</strong>  Presenta al usuario una máquina abstracta más fácil de programar que el hardware subyacente, ocultando su complejidad, y dando un tratamiento homogéneo a diferentes objetos de bajo nivel (archivos, proceso, dispositivos).</li>
                 <li><strong>Visión de Gestor de recursos:</strong> Controla y protege los recursos (procesador, dispositivos de E/S, memoria, etc.) entre los procesos y usuarios que compiten por ellos.</li>
                 <li><strong>Monitor simple residente:</strong>Un solo fragmento de código que se enlazaba con los programas, cargándose todo en memoria y ejecutándose junto con el programa (“biblioteca en tiempo de ejecución”).</li>
                 <br>
               </ul>
               <h5>Sistemas por lotes</h5>
               <br>
               <ul>
                <li>Se podrían considerar como los primeros SSOOs reales.</li>
                <li>El SSOO estaba almacenado en memoria.</li>
                <li>Cargaba un único trabajo en memoria (desde el lector de tarjetas).</li>
                <li>Ejecutaba el trabajo (generaba su salida).</li>
                <li>Cargaba el siguiente trabajo.</li>
                <li>Problemas.
                    <ul>
                        <li>Largas esperas entre lotes de trabajo.</li>
                        <li>La dificultad de manejar la concurrencia entre E/S y ejecución en CPU ayudó a estimular el desarrollo de los SSOO multiprogramados.</li>
                        <li>Carecen de interactividad entre el usuario y los trabajos que se ejecutan.</li>
                    </ul>
                </li>
               </ul>
               <br>
               <h5>Multiprogramado</h5>
               <p class="justificar"><strong>Objetivo:</strong>Aprovechar los tiempos de espera de un trabajo en la CPU para ejecutar instrucciones de otro trabajo.</p>
               <p class="justificar"><strong>Método:</strong>Mantener los trabajos simultáneamente en memoria, Elegir el trabajo a conmutar, Necesidad de usar interrupciones o DMA y Se optimiza la productividad (throughput) del sistema.</p>
               <br>
               <h5>Elementos necesarios</h5>
                <ul>
                  <li>Las rutinas de E/S deben estar suministradas por el SSOO.</li>
                  <li>Debe existir una gestión de memoria para poder asignar y controlar la memoria repartida entre varios trabajos.</li>
                  <li>Debe existir una planificación de la CPU. El SSOO debe elegir uno de entre los diferentes trabajos listos para ejecutarse que hay en memoria.</li>
                  <li>La asignación de los dispositivos es realizada por el SSOO.</li>
               </ul>
               <br>
               <h5>Tiempo compartido</h5>
               <p class="justificar"><strong>Objetivo:</strong>Permitir la interacción entre el usuario y el trabajo que se está ejecutando.</p>
               <p class="justificar"><strong>Método:</strong>Utilizar las técnicas de multiprogramación y planificación de la CPU para proporcionar a cada usuario una pequeña proporción del tiempo de CPU.</p>
               <p class="justificar"><strong>Características:</strong>
                <ul>
                  <li>Cada usuario tiene la impresión de disponer de la máquina completa.</li>
                  <li>Se intenta optimizar el tiempo de respuesta.</li>
                  <li>Basados en la asignación de fracciones de tiempo (se divide el tiempo de CPU de forma equitativa entre los procesos).</li>
                </ul></p>
                <br>
                <h5>Sistema de tiempo real</h5>
                <p class="justificar">El factor tiempo se convierte en una variable fundamental. Muy utilizados en sistemas empotrados. El sistema operativo debe responder siempre dentro de los márgenes requeridos por el sistema controlado, si nos salimos de esos márgenes, tendremos que buscar otras soluciones. Existen actualmente lenguajes de programación (Ada) que nos dan grandes posibilidades para controlar procesos en tiempo real.</p>
                <br>
                <h4>Entorno Hardware</h4>
                <ul>
                    <li>Sistema computador</li>
                    <li>Interrupciones y excepciones</li>
                    <li>Modo dual de operación</li>
                    <li>Protección de memoria</li>
                    <li>Protección de la CPU</li>
                </ul>
                <br>
                <h4>Estructura de sistema operativos</h4>
                <br>
                <h5>Estructura monolítica</h5>
                <p class="justificar">Es la estructura de los primeros sistemas operativos constituidos fundamentalmente por un solo programa compuesto de un conjunto de procedimientos entrelazados de tal forma que cada uno puede llamar a cualquier otro. Las características fundamentales de este tipo de estructura son:</p>
                <ul>
                    <li>Construcción del programa final a base de módulos compilados separadamente que se unen a través del ligador.</li>
                    <li>Buena definición de parámetros de enlace entre las distintas rutinas existentes, que puede provocar mucho acoplamiento.</li>
                    <li>Carecen de protecciones y privilegios al entrar a rutinas que manejan diferentes aspectos de los recursos de la computadora, como memoria, disco, etc.</li>
                </ul>
                <br>
                <p class="justificar">Generalmente están hechos a medida, por lo que son eficientes y rápidos en su ejecución y gestión, pero por lo mismo carecen de flexibilidad para soportar diferentes ambientes de trabajo o tipos de aplicaciones.</p>
                <div class="col-2">
                    <img src="introImg1/EstruMonoimg.png" width="300px" alt="Introduccion" class="rounded">
                </div>
                <br>
                <br>
                <h5>Estructura en capas</h5>
                <p class="justificar">A medida que fueron creciendo las necesidades de los usuarios y se perfeccionaron los sistemas, se hizo necesaria una mayor organización del software, del sistema operativo, donde una parte del sistema contenía subpartes y esto organizado en forma de niveles.</p>
                <p class="justificar">Se dividió el sistema operativo en pequeñas partes, de tal forma que cada una de ellas estuviera perfectamente definida y con un claro interfaz con el resto de los elementos.</p>
                <p class="justificar">Se constituyó una estructura jerárquica o de niveles en los sistemas operativos, el primero de los cuales fue denominado THE (Technische Hogeschool, Eindhoven), de Dijkstra, que se utilizó con fines didácticos. Se puede pensar también en estos sistemas como si fueran `multicapa'. Multics y Unix caen en esa categoría.</p>
                <div class="col-2">
                    <img src="introImg1/EstruCapimg.png" width="300px" alt="Introduccion" class="rounded">
                </div>
                <br>
                <p class="justificar">En la estructura anterior se basan prácticamente la mayoría de los sistemas operativos actuales. Otra forma de ver este tipo de sistema es la denominada de anillos concéntricos o "rings".</p>
                <div class="col-2">
                    <img src="introImg1/EstruCapimg2.png" width="300px" alt="Introduccion" class="rounded">
                </div>
                <br>
                <h5>Máquina Virtual</h5>
                <p class="justificar">Se trata de un tipo de sistemas operativos que presentan una interfaz a cada proceso, mostrando una máquina que parece idéntica a la máquina real subyacente. Estos sistemas operativos separan dos conceptos que suelen estar unidos en el resto de los sistemas: la multiprogramación y la máquina extendida. El objetivo de los sistemas operativos de máquina virtual es el de integrar distintos sistemas operativos dando la sensación de ser varias máquinas diferentes.</p>
                <p class="justificar">El núcleo de estos sistemas operativos se denomina monitor virtual y tiene como misión llevar a cabo la multiprogramación, presentando a los niveles superiores tantas máquinas virtuales como se soliciten. Estas máquinas virtuales no son máquinas extendidas, sino una réplica de la máquina real, de manera que en cada una de ellas se pueda ejecutar un sistema operativo diferente, que será el que ofrezca la máquina extendida al usuario.</p>
                <br>
                <h5>Cliente-Servidor</h5>
                <p class="justificar">El tipo más reciente de sistemas operativos es el denominado cliente-servidor, que puede ser ejecutado en la mayoría de las computadoras, ya sean grandes o pequeñas. Este sistema sirve para toda clase de aplicaciones, por tanto, es de propósito general y cumple con las mismas actividades que los sistemas operativos convencionales.</p>
                <p class="justificar">El núcleo tiene como misión establecer la comunicación y los servidores. Los procesos pueden ser tanto servidores como clientes. Por ejemplo, un programa de aplicación normal es un cliente que llama al servidor correspondiente para acceder a un archivo o realizar una operación de entrada/salida sobre un dispositivo concreto. A su vez, un proceso cliente puede actuar como servidor para otro".</p>
                <p class="justificar">Este paradigma ofrece gran flexibilidad en cuanto a los servicios posibles en el sistema final, ya que el núcleo provee solamente funciones muy básicas de memoria, entrada/salida, archivos y procesos, dejando a los servidores proveer la mayoría que el usuario final o programador puede usar. Estos servidores deben tener mecanismos de seguridad y protección que, a su vez, serán filtrados por el núcleo que controla el hardware.</p>
                <br>
                <h4>Sistema de Computador</h4>
                <ul>
                    <li>Los controladores de dispositivos tienen un búfer local, colas de peticiones y registros de control/estado.</li>
                    <li>La CPU transfiere los datos de/a memoria principal a/de los búferes locales.</li>
                    <li>Las E/S se realizan desde el dispositivo al búfer local del controlador.</li>
                    <li>Los controladores de dispositivo informan a la CPU que han finalizado mediante una interrupción.</li>
                </ul>
                <br>
                <h4>Interrupciones y excepciones</h4>
                <p>Gestor de excepciones:</p>
                <ul>
                    <li>Al detectarse la excepción, se transfiere el control al manejador de excepciones (igual que en las interrupciones).</li>
                    <li>Las excepciones se tratan en espacio de usuario.</li>
                    <li>El SSOO simplemente las notifica.</li>
                </ul>
                <br>
                <h4>Entidad de Ejecución</h4>
                <ul>
                    <li>Proceso = Programa en ejecución.</li>
                    <li>Proceso = Programa cargado en memoria y con recursos asignados.</li>
                    <li>Responsabilidades del SSOO: crear/destruir procesos, suspender/reanudar procesos, suministrar mecanismos para sincronizar y comunicar procesos.</li>
                </ul>
                <br>
                <h4>Componentes</h4>
                <h5>Gestor de memoria principal</h5>
                <ul>
                    <li>Asignar/Desasignar memoria a los programas.</li>
                    <li>Conocer en todo momento la memoria utilizada y quien la usa.</li>
                    <li>Decidir el tamaño de memoria que se asigna a cada proceso y cuando debe ser retirado de la misma.</li>
                </ul>
                <br>
                <h5>Gestor de archivos</h5>
                <ul>
                    <li>Archivo = Colección de datos (información) referenciada bajo un nombre.</li>
                    <li>Operaciones sobre archivos: Crear/borrar archivos o (directorios). Llamadas al sistema para su manipulación: leer, escribir, renombrar, etc. Servicios de backup, cuotas, etc.</li>
                </ul>
                <br>
                <h5>Gestor de E/S</h5>
                <p class="justificar">Los SSOOs modernos proporcionan una I/F estándar entre los programas y los dispositivos, es decir, utilizan las mismas funciones independientemente del dispositivo. El módulo del SSOO responsable de gestionar el tipo de dispositivo y encapsular el conocimiento específico del dispositivo es el manejador de dispositivo.</p>
                <br>
                <h5>Sistema de Protección</h5>
                <p class="justificar"><strong>Objetivo:</strong>Controlar los accesos de programas, procesos o usuarios, al sistema o a los recursos de usuario.</p>
                <p class="justificar"><strong>Método:</strong>Distinguir entre uso autorizado o no.</p>
               <ul>
                <li>Especificar el control que se debe imponer</li>
                <li>Suministrar los medios para su aplicación</li>
               </ul>
               <p class="justificar">El sistema de protección no está localizado en un único módulo, sino que es un mecanismo general a todo el SSOO.</p>
               <br>
               <h5>Intérprete de órdenes</h5>
               <p class="justificar">Proceso que maneja la interpretación de órdenes del usuario desde un terminal, para utilizar los servicios que proporciona el SSOO. Este proceso hace de interfaz con el usuario u operador del sistema. (csh, bash, ksh, etc.).</p>
               <br>
               <br>
            </div>
               <h4>Propiedades</h4>
               <br>
               <div class="col-3">
                <br>
                <h5>Eficacia</h5>
                <ul>
                    <li>Consumo: >40% de los ciclos de CPU.</li>
                </ul>
               </div>
               <br>
               <div class="col-3">
                <br>
                <h5>Fiabilidad</h5>
                <ul>
                    <li>Roustez: El SSOO debe responder de forma predecible a casos de error, incluidos fallos HW.</li>
                    <li>Protección: El SSOO debe protegerse a sí mismo y a los usuarios de acciones accidentales o malintencionadas.</li>
                </ul>
                <br>
                <br>
                </div>
                <div class="col-3">
                <br>
               <h5>Extensibilidad</h5>
               <ul>
                <li>Variar o crecer la funcionalidad del SSOO de forma sencilla.</li>
               </ul>
               </div>
               <div class="col-9">
               <h5>Tipos de estructuras o arquitectura</h5>
               <ul>
                <li>Toda la funcionalidad del SSOO se incluye en el núcleo.</li>
                <li>Todos los componentes del SSOO se ejecutan en modo supervisor.</li>
                <li>Empleado en sistemas pequeños.</li>
                <li>Difícil de modificar en tiempo de ejecución.</li>
                <li>Difícil de mantener.</li>
               </ul>
               <p><strong>Partes diferenciales:</strong> </p>
               <ul>
                <li>Núcleo dependiente:
                    <ul>
                        <li>Manejar las interrupciones del HW.</li>
                        <li>Manejo de bajo nivel de memoria y discos.</li>
                        <li>Trabajar con los manejadores de dispositivos de bajo nivel.</li>
                    </ul>
                </li>
                <br>
                <li>Núcleo independiente:
                    <ul>
                        <li>Ofrece las llamadas al sistema (“system calls”).</li>
                        <li>Manejar los sistemas de archivos.</li>
                        <li>Gestionar la planificación de procesos</li>
                    </ul>
                    <br>
                     <div class="col-2">
                        <img src="introImg2/NuIndimg.png" width="400px" alt="Introduccion" class="rounded">
                     </div>
                </li>
               </ul>
               <br>
               <br>
               <h5>UKernel</h5>
               <ul>
                <li>Manejo de procesos e hilos.</li>
                <li>Manejo bajo de memoria.</li>
                <li>Soporte a las comunicaciones.</li>
                <li>Manejo de interrupciones y operaciones de bajo nivel de E/S.</li>
                <li>Se usan procesos “servidores” que se encargan de ofrecer el resto de los servicios (por ejemplo, el de sistema de archivos).</li>
                <li>Menor rendimiento que la arquitectura monolítica debido a la sobrecarga de comunicaciones.</li>
                <li>Empleado en sistemas grandes.</li>
                <li>Fácil de modificar en tiempo de ejecución.</li>
                <li>Más adaptable que la arquitectura monolítica.</li>
                <li>Sólo el micronúcleo se ejecuta en modo supervisor.</li>
               </ul>
               <br>
               <div class="col-2">
                        <img src="introImg2/Ukernelimg.png" width="400px" alt="Introduccion" class="rounded">
                     </div>
                     <br>
                     <br>
                     <br>
               </div>
               <br>
               <h4>Links</h4>
               <p class="justificar">Estos son algunos links interesantes que se vieron en el modulo</p>
             <table class="table table-dark table-striped">
                 <tr>
                     <th>Links</th>
                 </tr>
                 <tr>
                     <td><a href="https://www.peerspot.com/categories/operating-systems-os-for-business" target="_blank">Estadísticas de Sistemas Operativos de Negocios</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://gs.statcounter.com/os-market-share/mobile/worldwide" target="_blank">Estadísticas de Sistemas Operativos Móviles</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://www.techjockey.com/category/server-operating-system" target="_blank">Estadísticas de Sistemas Operativos Server</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://internetpasoapaso.com/ms-dos/#:~:text=MS%2DDOS%20tambi%C3%A9n%20conocido%20como,de%20entrada%20y%20salida%20como" target="_blank">Importancia del CMD</a></td>
                 </tr>
                 <tr>
                    <td><a href="https://www.xataka.com/basics/comandos-basicos-para-dar-tus-primeros-pasos-consola-windows-cmd" target="_blank">Comandos básicos de CMD</a></td>
                </tr>
             </table>
               <br>
               <!--SECCIÓN 5-->
               <h2 class="centrar">Módulo 5</h2>
                <p class="top-space"></p>
                <h3>Semana 5</h3>
                <br>
               <div class="col-9">
               <br>
               <h4>Recuros administrados por el S.O</h4>
               <h4>Control de Procesos</h4>
               <br>
               <div class="col-2">
                <img src="introImg2/Controlimg.png" width="400px" alt="Introduccion" class="rounded">
               </div>
               <br>
               <h5>¿Qué es un proceso?</h5>
               <p class="justificar">Un proceso puede informalmente entenderse como un programa en ejecución. Formalmente un proceso es "Una unidad de actividad que se caracteriza por la ejecución de una secuencia de instrucciones, un estado actual, y un conjunto de recursos del sistema asociados.</p>
               <br>
               <h5>Modelo de Procesos</h5>
               <p>Posee las siguientes Características:</p>
               <ul>
                <li>Todo el software ejecutable, inclusive el Sistema Operativo, se organiza en varios procesos secuenciales o procesos.</li>
                <li>Un proceso incluye al programa en ejecución y a los valores activos del contador, registros y variables de este.</li>
                <li>Conceptualmente cada proceso tiene su propia CPU virtual.</li>
                <li>Un proceso es una actividad de un cierto tipo, que tiene un programa, entrada, salida y estado.</li>
               </ul>
               <p class="justificar">Un solo procesador puede ser compartido entre varios procesos con cierto “algoritmo de planificación”, el cual determina cuándo detener el trabajo en un proceso y dar servicio a otro distinto.</p>
               <br>
               <div class="col-2">
                <img src="introImg2/MProcesoimg.png" width="500px" alt="Introduccion" class="rounded">
               </div>
               <br>
               <p class="justificar">En cuanto a las jerarquías de procesos es necesario señalar que los Sistemas Operativos deben disponer de una forma de crear y destruir procesos cuando se requiera durante la operación, teniendo además presente que los procesos pueden generar procesos hijos mediante llamadas al Sistema Operativo, pudiendo darse ejecución en paralelo.</p>
               <br>
               <h4>¿Qué es un sistema operativo Multihilo?</h4>
               <p class="justificar">Es aquel Sistema Operativo que posee varios hilos de ejecución. Un hilo de Ejecución o subproceso es una característica que permite a una aplicación realizar varias tareas a la vez (concurrentemente). Los distintos hilos de ejecución comparten una serie de recursos tales como el espacio de memoria, los archivos abiertos, situación de autenticación, etc.</p>
               <p class="justificar">Los procesos son creados y destruidos por el sistema operativo, así como también este se debe hacer cargo de la comunicación entre procesos, pero lo hace a petición de otros procesos. El mecanismo por el cual un proceso crea otro proceso se denomina bifurcación (fork). Los nuevos procesos son independientes y no comparten memoria (es decir, información) con el proceso que los ha creado. En los sistemas operativos multihilo es posible crear tanto hilos como procesos. La diferencia es en que un proceso solamente puede crear hilos para sí mismo.</p>
               <br>
               <p><strong>No hay un acuerdo universal sobre una definición de proceso, pero sí algunas definiciones aceptadas:</strong> </p>
               <ul>
                <li>Un programa que se está ejecutando</li>
                <li>Una actividad asincrónica.</li>
                <li>El emplazamiento del control de un procedimiento que está siendo ejecutado.</li>
                <li>Aquello que se manifiesta por la existencia en el Sistema Operativo de un bloque de control de proceso.</li>
                <li>Aquella entidad a la cual son asignados los procesadores.</li>
                <li>La unidad despachable.</li>
               </ul>
               <br>
               <h4>Estados de un Proceso</h4>
               <p class="justificar">El principal trabajo del procesador es ejecutar las instrucciones de máquina que se encuentran en memoria principal. Estas instrucciones se encuentran en forma de programas. Para que un programa pueda ser ejecutado, el sistema operativo crea un nuevo proceso, y el procesador ejecuta una tras otra las instrucciones de este.</p>
               <ul>
                <li>Cada proceso es una entidad independiente pero frecuentemente debe interactuar con otros procesos.</li>
                <li>Los procesos pueden bloquearse en su ejecución porque:
                   <ul>
                    <li>Desde el punto de vista lógico no puede continuar porque espera datos que aún no están disponibles.</li>
                    <li>El Sistema Operativo asignó la CPU a otro proceso.</li>
                   </ul>
                </li>
               </ul>
               <br>
               <h5>Los estados que puede tener un proceso son:</h5>
               <ul>
                <li><strong>En ejecución: </strong>utiliza la CPU en el instante dado.</li>
                <li><strong>Listo: </strong>ejecutable, se detiene en forma temporal para que se ejecute otro proceso.</li>
                <li><strong>Bloqueado: </strong>no se puede ejecutar debido a la ocurrencia de algún evento externo.</li>
               </ul>
               <br>
               <h4>Modelo de estados</h4>
               <h5>Modelo de dos estados</h5>
               <br>
               <div class="col-2">
                <img src="introImg2/Mo2img.png" width="500px" alt="Introduccion" class="rounded">
               </div>
               <br>
               <p class="justificar">En este modelo, un proceso puede estar ejecutándose o no. Cuando se crea un nuevo proceso, se pone en estado de No ejecución. En algún momento el proceso que se está ejecutando pasará al estado No ejecución y otro proceso se elegirá de la lista de procesos listos para ejecutar para ponerlo en estado Ejecución.</p>
               <p class="justificar">De esta explicación se desprende que es necesario que el sistema operativo pueda seguirles la pista a los procesos, conociendo su estado y el lugar que ocupa en memoria. Además, los procesos que no se están ejecutando deben guardarse en algún tipo de cola mientras esperan su turno para ejecutar.</p>
               <br>
               <h5>Modelo de cinco estados</h5>
               <br>
               <div class="col-2">
                <img src="introImg2/M5img.png" width="500px" alt="Introduccion" class="rounded">
               </div>
               <br>
               <p class="justificar">El modelo anterior de dos estados funcionaría bien con una cola FIFO y planificación por turno rotatorio para los procesos que no están en ejecución, si los procesos estuvieran siempre listos para ejecutar. En la realidad, los procesos utilizan datos para operar con ellos, y puede suceder que no se encuentren listos, o que se deba esperar algún suceso antes de continuar, como una operación de Entrada/Salida.</p>
               <p class="justificar">Es por lo que se necesita un estado donde los procesos permanezcan bloqueados esperando hasta que puedan proseguir. Se divide entonces al estado No ejecución en dos estados: Listo y Bloqueado. Se agregan además un estado Nuevo y otro.</p>
               <br>
               <p><strong>Los cinco estados del diagrama son los siguientes:</strong></p>
               <ul>
                <li><strong>Ejecución: </strong>El proceso está actualmente en ejecución.</li>
                <li><strong>Listo: </strong>El proceso está listo para ser ejecutado, sólo está esperando que el planificador así lo disponga.</li>
                <li><strong>Bloqueado: </strong>El proceso no puede ejecutar hasta que no se produzca cierto suceso, como una operación de Entrada/Salida.</li>
                <li><strong>Nuevo: </strong>El proceso recién fue creado y todavía no fue admitido por el sistema operativo. En general los procesos que se encuentran en este estado todavía no fueron cargados en la memoria principal.</li>
                <li><strong>Terminado: </strong>El proceso fue expulsado del grupo de procesos ejecutables, ya sea porque terminó o por algún fallo, como un error de protección, aritmético, etc.</li>
               </ul>
               <br>
               <p class="justificar">Los nuevos estados Nuevo y Terminado son útiles para la gestión de procesos. En este modelo los estados Bloqueado y Listo tienen ambos una cola de espera. Cuando un nuevo proceso es admitido por el sistema operativo, se sitúa en la cola de listos. A falta de un esquema de prioridades ésta puede ser una cola FIFO. Los procesos suspendidos son mantenidos en una cola de bloqueados. Cuando se da un suceso se pasan a la cola de listos los procesos que esperaban por ese suceso.</p>
               <p class="justificar">Si existe un esquema con diferentes niveles de prioridad de procesos es conveniente mantener varias colas de procesos listos, una para cada nivel de prioridad, lo que ayuda a determinar cuál es el proceso que más conviene ejecutar a continuación.</p>
               <p class="justificar">Durante su existencia un proceso pasa por una serie de estados discretos, siendo varias las circunstancias que pueden hacer que el mismo cambie de estado. Debido a ello se puede establecer una “Lista de Listos” para los procesos “listos” y una “Lista de Bloqueados” para los “bloqueados”.</p>
               <br>
               <h4>Lista de Listos</h4>
               <p class="justificar">La “Lista de Listos” se mantiene en orden prioritario y la “Lista de Bloqueados” está desordenada, ya que los procesos se desbloquean en el orden en que tienen lugar los eventos que están esperando. Al admitirse un trabajo en el sistema se crea un proceso equivalente y es insertado en la última parte de la “Lista de Listos”.La asignación de la CPU al primer proceso de la “Lista de Listos” se denomina “Despacho”, que es ejecutado por una entidad del Sistema Operativo llamada “Despachador”.</p>
               <br>
               <h4>Bloqueados</h4>
               <p class="justificar">El “Bloqueo” es la única transición de estado iniciada por el propio proceso del usuario, puesto que las otras transiciones son iniciadas por entidades ajenas al proceso.</p>
               <br>
               <h5>Programa VS. Proceso</h5>
               <ul>
                <li><strong>Programa: </strong>Conjunto de instrucciones, código. Elemento pasivo.</li>
                <li><strong>Proceso: </strong>Programa en ejecución. (Ente dinámico) Un programa puede levantar varios procesos. Tiene asociado un espacio de direcciones.</li>
               </ul>
               <br>
               <div class="col-2">
                <img src="introImg2/PvsPimg.png" width="500px" alt="Introduccion" class="rounded">
               </div>
               <br>
               <h5>Espacio de Direcciones</h5>
               <p class="justificar">El espacio de direcciones es el espacio en memoria asignado al proceso. Aquí se encuentra el código del proceso y los datos que este utiliza. Desde el punto de vista del proceso, el Address Space es la única memoria existente en el sistema, no pudiendo acceder a direcciones foráneas. En el caso de sistemas sin paginación, el espacio de direcciones no puede ser particionado en páginas, y ser cargado por partes o llevado parcialmente a swap; resultando en que el bloque de memoria está realmente presente ya sea en RAM o disco.</p>
               <div class="col-2">
                <img src="introImg2/EPDimg.png" width="300px" alt="Introduccion" class="rounded">
               </div>
               <br>
               <p class="justificar">Cuando se tiene paginación, entonces el espacio de direcciones es dividido en páginas, y resultando en que no todo este en RAM, sino solo una porción. A este concepto de un espacio que realmente no está por completo ni en memoria, ni en disco; se le denomina Espacio de Direcciones Virtual.</p>
               <br>
               <h5>Process Control Block</h5>
               <p class="justificar">El Process Control Block, (Bloque del control del Proceso) es una ficha que lleva el sistema operativo con toda la información administrativa de un proceso. Permite conocer con exactitud el estado del proceso, en que parte de su código se está ejecutando, cuál es su número identificador, cuanta memoria tiene asociada, cuales archivos están abiertos, etc.</p>
               <div class="col-2">
                <img src="introImg2/ProBlockimg.png" width="300px" alt="Introduccion" class="rounded">
               </div>
               <br>
               <h4>El PCB o BCP</h4>
               <p class="justificar">El sistema operativo, para correr un proceso, necesita saber cierta información importante de él, y esta, se encuentra almacenada en un registro, que es el "Bloque de control de proceso BCP". Cuando un proceso termina, su información que estaba almacenada en el Bloque se elimina, y este puede ser utilizado por otros procesos.</p>
               <br>
               <h5>Tablas de Procesos</h5>
               <p class="justificar">La tabla de procesos es una estructura en memoria que contiene la ubicación de los PCB de todos los procesos del sistema. A través de esta, el kernel puede conocer el estado de cada proceso, saber en parte de la memoria se encuentra, etc.</p>
               <br>
               <div class="col-2">
                <img src="introImg2/Tproceimg.png" width="700px" alt="Introduccion" class="rounded">
               </div>
               <br>
               <h5>Ubicación de los Procesos</h5>
               <br>
               <div class="col-2">
                <img src="introImg2/UbiProceimg.png" width="500px" alt="Introduccion" class="rounded">
               </div>
               <br>
               <br>
               <h4>Links</h4>
               <p class="justificar">Estos son algunos links interesantes que se vieron en el modulo</p>
             <table class="table table-dark table-striped">
                 <tr>
                     <th>Links</th>
                 </tr>
                 <tr>
                     <td><a href="https://www.hostinger.es/tutoriales/linux-comandos" target="_blank">34 Comandos básicos de Linux</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://www.tutorialspoint.com/linux_terminal_online.php" target="_blank">Terminal de Linux</a></td>
                 </tr>
             </table>
               <!--SECCIÓN 6-->
               <h2 class="centrar">Módulo 6</h2>
                <p class="top-space"></p>
                <h3>Semana 6 y 7</h3>
                <br>
               <div class="col-9">
               <h4>Curso de Linux</h4>
               <h4>Algunos Comandos Básicos</h4>
               <p class="justificar">Algunos de ellos como man, ls, chmod y umask ya han sido referenciados, otros se mencionarán más adelante en dependencia de los temas que se traten. Muchos de estos comandos están presentes también en los sistemas Unix, aunque a veces varían sus opciones y argumentos en dependencia de las versiones. Por esto no puede encontrarse una documentación que diga la última palabra respecto a uno u otro comando, la práctica es la mejor forma de comprobar cómo funciona cada uno. Para su mejor comprensión los clasificamos en diferentes categorías.</p>
               <br>
               <h4>Categorias</h4>
               <h5>Comandos para manipular ficheros y directorios</h5>
               <ul>
                <li>Comando ls</li>
                <li>Comando cd</li>
                <li>Comando pwd </li>
                <li>Comando mkdir</li>
                <li>Comando mv</li>
                <li>Comando cp</li>
                <li>Comando rm</li>
                <li>Comando chown</li>
                <li>Ayuda en el sistema</li>
               </ul>
               <br>
               <h5>Comandos para paginar, visualizar y editar ficheros</h5>
               <ul>
                <li>Comando cat</li>
                <li>Editor pico</li>
                <li>Editor vi</li>
                <li>Comandos more y less</li>
                <li>Ayuda en el sistema</li>
               </ul>
               <br>
               <h5>Comandos para hacer búsquedas de ficheros y patrones</h5>
               <ul>
                <li>Comando grep</li>
                <li>Comando find</li>
                <li>Comando locate</li>
                <li>Ayuda en el sistema</li>
               </ul>
               <br>
               <h5>Comandos para filtrar ficheros</h5>
               <ul>
                <li>Comando file</li>
                <li>Comando sort</li>
                <li>Comando uniq</li>
                <li>Comandos tail y head</li>
                <li>Comando wc</li>
                <li>Comando stat</li>
                <li>Ayuda en el sistema</li>
               </ul>
               <br>
               <h5>Comandos para compactar y agrupar ficheros</h5>
               <ul>
                <li>Comandos gzip y gunzip</li>
                <li>Comando tar</li>
                <li>Ayuda en el sistema</li>
               </ul>
               <br>
               <h5>Comandos para comunicación entre usuarios</h5>
               <ul>
                <li>Comando write</li>
                <li>Comando wall</li>
                <li>Comando talk</li>
                <li>Ayuda en el sistema</li>
               </ul>
               <br>
               <h5>Comandos para desconectarse del sistema </h5>
               <ul>
                <li>Comando exit</li>
                <li>Comando logout</li>
                <li>Ayuda en el sistema</li>
               </ul>
               <br>
               <h5>Comandos para administrar usuarios y grupos </h5>
               <ul>
                <li>Comando useradd</li>
                <li>Comando userdel</li>
                <li>Comando passwd</li>
                <li>Comando usermod</li>
                <li>Comando chfn</li>
                <li>Comandos groupadd y groupdel</li>
                <li>Comando groupmod</li>
                <li>Comando gpasswd</li>
                <li>Comando su</li>
                <li>Comando newgrp</li>
                <li>Ayuda en el sistema</li>
               </ul>
               <br>
               <h5>Comandos varios </h5>
               <ul>
                <li>Comando echo</li>
                <li>Comando alias</li>
                <li>Comando tty</li>
                <li>Comando du</li>
                <li>Comando id</li>
                <li>Comando who</li>
                <li>Comando w</li>
                <li>Comando finger</li>
                <li>Comando ping</li>
                <li>Comando ifconfig</li>
                <li>Ayuda en el sistema</li>
               </ul>
               <br>
               <h4>Flujo de datos</h4>
               <p class="justificar">Todos los procesos (programas en ejecución) tienen asociados tres flujos (streams) de datos principales. Estos son:</p>
               <ul>
                <li><strong>La entrada estándar: </strong>Es donde puede tomar los datos que maneja y que no se indican mediante argumentos u opciones. Por defecto se toma a partir del teclado.</li>
                <li><strong>La salida estándar: </strong>Es donde un proceso escribe los resultados de su ejecución. Por defecto es la terminal donde se invocó el programa correspondiente.</li>
                <li><strong>La salida de errores: </strong>Es donde un proceso escribe los posibles errores durante su ejecución. Por defecto es la terminal donde se invocó el programa correspondiente.</li>
               </ul>
               <p class="justificar">Los flujos de datos se almacenan en descriptores de ficheros que se identifican por un número en la forma siguiente: 0: representa la entrada estándar. 1: representa la salida estándar.  2: representa la salida de errores.</p>
               <br>
               <h4>Redireccionamiento</h4>
               <p class="justificar"></p>
               <ul>
                <li>[x]>salida: indica el redireccionamiento del flujo de datos x al fichero nombrado salida. De no indicarse x se asumirá la salida estándar del programa que se haya invocado, o sea, 1.</li>
                <li>[x](<)entrada: indica el redireccionamiento del contenido del fichero nombrado entrada hacia flujo de datos x. De no indicarse x se asumirá la entrada estándar del comando que se haya invocado, o sea, 0.</li>
               </ul>
               <br>
               <div class="col-2">
                <img src="introImg2/Rediimg.png" width="500px" alt="Introduccion" class="rounded">
               </div>
               <p class="justificar">Siempre que se emplee la forma [x]>salida, si el fichero salida existe se sobrescribirá y si no, se creará. Para añadirle algo más a su contenido anterior (append) en lugar de sobrescribirlo, se puede emplear >>.</p>
               <br>
               <h4>Tuberías</h4>
               <p class="justificar">son un poderoso mecanismo del shell, permite tomar la salida de un comando y pasársela como entrada a otro. Muchos de los comandos mencionados anteriormente, que reciben como argumento un fichero, en caso de omitirse este, utilizan su entrada estándar. Esta entrada puede provenir a su vez de la salida de otros comandos. Lo que permite realizar diversos tipos de filtrado. Pueden estar formadas por un número ilimitado de comandos. Estos no se ejecutan secuencialmente, o sea no se espera a que termine uno para ejecutar el siguiente, sino que se va haciendo de forma concurrente. El carácter que se emplea para separar un comando de otro mediante una tubería es |.</p>
               <br>
               <h4>Entorno de trabajo en bash</h4>
               <p class="justificar">Un entorno de trabajo en Linux no es más que la configuración que posee un usuario durante su interacción con el sistema y más específicamente con el shell. Las características del entorno para el caso de bash pueden ser la forma en que se muestra el prompt, los alias y funciones definidos y las variables del entorno de forma general, ya que estas definen el comportamiento de muchos programas y comandos. Las facilidades para cambiar el entorno de trabajo dependen de las capacidades del shell que se utilice.</p>
               <br>
               <h4>Variables del entorno</h4>
               <p class="justificar">Almacenan valores que describen las propiedades del entorno de trabajo. Un usuario puede definir sus propias variables o modificar las ya existentes. Para asignarle valor a una variable en el shell se emplea el operador = entre el nombre de la variable y el valor asignado (no deben haber espacios intermedios).</p>
               <ul>
                <li>Ejemplo: $ MENSAJE="Hola amigo"</li>
               </ul>
               <br>
               <p class="justificar">Para acceder al valor de una variable se emplea el caracter $ seguido por el nombre de la variable. Para imprimir en la terminal el valor de una variable se puede utilizar el comando echo.</p>
               <ul>
                <li>Ejemplo: $ echo $MENSAJE Hola amigo</li>
               </ul>
               <br>
               <p class="justificar">Dentro de un shell se pueden ejecutar otros shells que serían hijos del primero (subshells) heredando todo o parte del entorno de trabajo del padre. Para que una variable mantenga su valor en los shells hijos es necesario indicarlo explícitamente mediante el comando export. Ejemplo:</p>
               <ul>
                <li>$ export MENSAJE</li>
               </ul>
               <br>
               <p class="justificar">Tanto la asignación del valor como el exportar una variable se pueden hacer a la vez:</p>
               <ul>
                <li>$ export MENSAJE="Hola amigo"</li>
               </ul>
               <br>
               <p class="justificar">Para ver las variables del entorno definidas se puede emplear el comando set. Este además se relaciona con las opciones que es otra forma de regir el comportamiento del shell. Las opciones se activan (on) o desactivan (off). Estas se utilizan para indicar propiedades del shell muy específicas por lo que no nos vamos a detener en ellas. Si se desea conocer más al respecto se puede hacer $ help set | less. Para eliminar el valor de una variable se emplea el comando unset. Ejemplo:</p>
               <ul>
                <li>$ unset MENSAJE</li>
               </ul>
               <br>
               <h4>Variables del entorno</h4>
               <p class="justificar">Almacenan valores que describen las propiedades del entorno de trabajo. Un usuario puede definir sus propias variables o modificar las ya existentes. Para asignarle valor a una variable en el shell se emplea el operador = entre el nombre de la variable y el valor asignado (no deben haber espacios intermedios).</p>
               <ul>
                <li>Ejemplo: $ MENSAJE="Hola amigo"</li>
               </ul>
               <br>
               <p class="justificar">Para acceder al valor de una variable se emplea el caracter $ seguido por el nombre de la variable. Para imprimir en la terminal el valor de una variable se puede utilizar el comando echo.</p>
               <ul>
                <li>Ejemplo: $ echo $MENSAJE Hola amigo</li>
               </ul>
               <br>
               <h4>Variables del entorno bash</h4>
               <h5>PATH</h5>
               <p class="justificar">guarda la secuencia de caminos donde el shell busca los programas que se intenten ejecutar en la línea de comandos cuando no se utilizan los caminos absolutos. Estos caminos se separan por el carácter “:”.  Ejemplo:</p>
               <ul>
                <li>Ejemplo: $ MENSAJE="Hola amigo"</li>
               </ul>
               <br>
               <p class="justificar">Para acceder al valor de una variable se emplea el caracter $ seguido por el nombre de la variable. Para imprimir en la terminal el valor de una variable se puede utilizar el comando echo.</p>
               <ul>
                <li>$ echo $PATH
                    /bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin
                    </li>
               </ul>
               <p class="justificar">Para añadir un nuevo camino puede hacerse:</p>
               <ul>
                <li>$ export PATH=$PATH: /bin</li>
               </ul>
               <br>
               <h5>USER</h5>
               <p class="justificar">Contiene el login del usuario actual.</p>
               <br>
               <h5>PAGER</h5>
               <p class="justificar">Almacena el paginador utilizado por defecto por algunos programas. Por ejemplo, el comando man utiliza esta variable para determinar que paginador empleará, aunque primero chequea otra variable llamada MANPAGER y si esta no tiene valor entonces acude a PAGER, que de no tener valor tampoco, asumirá al less como paginador por defecto. También asociada a man existe la variable MANPATH donde se especifican los caminos de los manuales que despliega man, y LANG para indicar el idioma.</p>
               <ul>
                <li>$ export PAGER=more</li>
                <li>$ man bash</li>
               </ul>
                <br>
                <h5>HOME</h5>
                <p class="justificar">Guarda el directorio base del usuario actual.</p>
                <ul>
                    <li>$ echo $HOME
                        /home/pepe
                        </li>
                </ul>
                <br>
                <h5>Editor</h5>
                <p class="justificar">Contiene el editor por defecto del usuario actual. De no tener valor asociado se utiliza vi. En entornos gráficos se pueden indicar editores visuales, aunque para ello se prefiere emplear la variable VISUAL. Más adelante veremos un ejemplo del uso de EDITOR.</p>
                <br>
                <h5>PS1</h5>
                <p class="justificar">Almacena la estructura del prompt principal del usuario. Permite una serie de macros.</p>
                <ul>
                    <li>\d : contiene la fecha del sistema.</li>
                    <li>\h : contiene el nombre de la máquina.</li>
                    <li>\T : contiene la hora del sistema.</li>
                    <li>\u : contiene el login del usuario.</li>
                    <li>\w : contiene el nombre completo del directorio de trabajo actual.</li>
                    <li>\W : contiene la base del nombre del directorio actual (Ejemplo: para /home/pepe/doc la base es doc).</li>
                    <li>\$ : si el ID del usuario es 0 (root) contiene el valor # y sino, $.</li>
                    <li>\# : contiene el número del comando actual desde la creación del shell.</li>
                </ul>
                <br>
                <p class="justificar">El prompt principal por defecto tiene la forma: "[\u@\h \W]\$ "</p>
                <ul>
                    <li>$ export PS1="[\T,\u\#]\$ "
                        [14:12:15,pepe 315]$
                        </li>
                </ul>
                <br>
                <h5>PS2</h5>
                <p class="justificar">Guarda el prompt secundario. Este es el que se presenta cuando el shell no puede interpretar lo que se ha escrito hasta el momento. Normalmente el Shell interpreta lo tecleado cuando se pulsa retorno. En caso de que no se haya completado una estructura interpretable bash muestra el prompt secundario, que por defecto es "> ". Para forzar a que bash no interprete algo después del retorno se escribe el caracter ``\'' antes del retorno.</p>
                <br>
                <div class="col-2">
                    <img src="introImg2/PS2img.png" width="500px" alt="Introduccion" class="rounded">
                   </div>
                   <br>
                <p class="justificar">En este ejemplo se muestra cómo se emplean las estructuras de control de bash, particularmente para un lazo tipo for. Como ya se ha mencionado existen otras estructuras de las cuales se podrá encontrar información en el manual de bash. Esta secuencia de código permite buscar recursivamente en el directorio /tmp todos los ficheros regulares cuyo tamaño exceda 1M y para cada uno de ellos se ejecutan los comandos stat y rm en forma interactiva. También se imprimen líneas divisorias.</p>
                <br>
                <h5>HISTFILE</h5>
                <p class="justificar">Almacena el nombre absoluto del fichero que contiene el historial de comandos para cada usuario. También existen HISTFILESIZE, HISTCMD e HISTSIZE. Esta última indica el tamaño del historial de comandos, que por defecto es de 1000 comandos.</p>
                <ul>
                    <li>$ echo $HISTFILE
                        /home/pepe/.bash_history
                        </li>
                </ul>
                <br>
                <h5>PWD</h5>
                <p class="justificar">Contiene el directorio de trabajo actual. Esta variable la pueden emplear algunos programas para saber desde donde se invocaron.</p>
                <br>
                <h5>SECONDS</h5>
                <p class="justificar">Almacena la cantidad de segundos transcurridos desde la invocación del shell actual.</p>
                <br>
                <h4>Ficheros y perfiles</h4>
                <p class="justificar">Para cada usuario existen tres ficheros muy importantes que permiten definir en gran medida las características del shell durante la interacción con este. Estos constituyen shells scripts y se conocen como ficheros perfiles o profiles:</p>
                <ul>
                    <li>.bash_profile: se ejecuta siempre que se abra una nueva sesión en el sistema. Cada vez que un usuario se conecte al sistema se ejecutará el script .</li>
                    <li>.bash_profile, en el caso de que se utilice a bash como shell. Para ser compatible con sus versiones anteriores, bash en caso de que no existiera .bash_profile, ejecuta .bash_login, o si no, .profile. En este fichero se pueden colocar las asignaciones a las variables del entorno siendo debidamente exportadas a través de export. También se puede establecer la máscara de permisos usando umask. Existe además un profile general ubicado en /etc/profile que se ejecuta también siempre que un usuario inicia una sesión en el sistema antes de su profile particular.</li>
                    <li>.bash_logout: se ejecuta al terminar una sesión de trabajo. Puede contener comandos para salvar lo hecho durante la sesión.</li>
                    <li>.bashrc: se ejecuta siempre que se invoque un nuevo shell. Por lo general en él se colocan las definiciones de funciones y los alias de comandos. El fichero .bashrc que posee cada usuario por defecto ejecuta primero a /etc/bashrc.</li>
                </ul>
                <p class="justificar">Cuando se crea un nuevo usuario se le colocan en su directorio base estos tres ficheros cuyos patrones están el directorio /etc/skel.</p>
                <br>
                <h4>Ejecución en bash</h4>
                <p class="justificar">Existen dos formas de ejecutar un shell script en el bash: Invocándolo directamente por su nombre. Para esto el camino al fichero que lo representa debe encontrarse en la variable PATH del entorno, sino será necesario especificar el camino completo del fichero o relativo al directorio actual. El fichero debe, además, poseer los permisos de ejecución adecuados. Lo que ocurrirá en este caso es que se creará un shell hijo que será el que realmente ejecute (interprete) al script. Utilizando el comando source. De esta forma se ejecutará el script en el shell actual. En este caso no será necesario que el fichero correspondiente posea permisos de ejecución. El comando se puede sustituir por el carácter punto.</p>
                <p class="justificar">Por ejemplo, si se modificara él .bash_profile no será necesario, para activar los cambios, desconectarse y conectarse nuevamente al sistema, simplemente se puede hacer:</p>
                <u>
                    <li>$ source .bash_profile ó 
                        $ . .bash_profile
                        </li>
                </u>
                <p class="justificar">Un ejercicio interesante puede ser hacer un Shell script (editar un fichero) llamado program.sh con la siguiente línea: </p>
                <ul>
                    <li>echo $SECONDS</li>
                </ul>
                <p class="justificar">Ejecutar luego:</p>
                <ul>
                    <li>$ . program.sh</li>
                </ul>
                <P class="justificar">Por último, asignarle al fichero permisos de ejecución para ejecutarlo de la forma tradicional:</P>
                <ul>
                    <li>$ chmod +x program.sh
                        $ ./program.sh
                        </li>
                </ul>
               </div>
               <br>
               <h4>Links</h4>
               <p class="justificar">Estos son algunos links interesantes que se vieron en el modulo</p>
             <table class="table table-dark table-striped">
                 <tr>
                     <th>Links</th>
                 </tr>
                 <tr>
                     <td><a href="https://es.wikipedia.org/wiki/Virtualizaci%C3%B3n" target="_blank">Virtualización</a></td>
                 </tr>
                 <tr>
                     <td><a href="https://www.fpgenred.es/VirtualBox/caractersticas_de_virtualbox.html" target="_blank">Características de Virtual Box</a></td>
                 </tr>
                 <tr>
                    <td><a href="https://es.wikipedia.org/wiki/Anexo:Caracter%C3%ADsticas_de_Ubuntu" target="_blank">Características de Ubuntu</a></td>
                </tr>
                <tr>
                    <td><a href="https://www.redeszone.net/tutoriales/servidores/controlar-permisos-archivos-carpetas-servidor-linux/" target="_blank">Permiso de usuario en archivos -Linux</a></td>
                </tr>
             </table>
            </div>
        </div>
    </div>
            </section> <!--END CONTAINER-->
            <style>
                .img-container {
                  text-align: center;
                }
              </style>
            <div class="img-container">
                <img src="introImg1/FN1img.jpg" alt="Introducción" class="rounded" id="calculadora">
            </div>
            <p class="top-space"></p>
                <div>
                    <a href="./Intro1.html" class="btn btn-dark" id="btPar2">Regresar</a>
                    <a href="introParcial2.html" class="btn btn-dark" id="btPar1">Ir a parcial 2</a>
                </div>
        </div>   

    <p class="top-space"></p>
    <p class="top-space"></p>
    <footer class="pieDePagina">Grupo #6, Ingeniería en Sistemas 5090-23, Sección A</footer>
    <p class="top-space"></p>
      <!--Dependencia JavaScript de bootstrap-->
<script src="js/bootstrap.bundle.min.js"></script> 
</body>
</html>